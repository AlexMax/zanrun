#library "zanrun"
#include "zcommon.acs"

#define PLAYERMAX 32
#define MAXCHECKPOINTS 255
#define TICRATE 35
#define FRACBITS 16
#define FRACUNIT (1 << FRACBITS)
#define SECONDS_IN_MINUTE 60
#define MAXIDS 4000

// Designate the tics where player hits the start/cp
int p_starttic[PLAYERMAX];
int p_checkpoint[PLAYERMAX][MAXCHECKPOINTS];
int p_cstarttic[PLAYERMAX]; //clientside starttic [Jroc]
int csmode; //clientside z_smode check

// Stores the players best time on this map.
int p_top_time[PLAYERMAX];
int p_top_checkpoint[PLAYERMAX][MAXCHECKPOINTS];

//For the teleporter

int GotRL[PLAYERMAX]; //track player's rockets for rjump and ctf flag running
int rammo[PLAYERMAX];
int playerhealth[PLAYERMAX];
int playerarmor[PLAYERMAX];

#define ARMORTYPES	4

str armor_types[ARMORTYPES] = {
  "ArmorBonus",
  "GreenArmor",
  "BlueArmor",
  "BlueArmorForMegasphere"
};

str playerarmortype[PLAYERMAX];

int teleportclearinv;
int gone[64];

//============Personal Timer, Checkpoints and Personal Bests================


// The default script to start the map with.
script 100 ENTER {
	//print(s:"100 ENTER"); //debug
    ClearInventory();
	GiveInventory( "ArmorBonus", 1 ); // Fix for broken GetArmorType().
	TakeInventory( "Armor", 1 );   
    SetActorProperty(0, APROP_Health, 100);
	if (GetCvar("z_smode") == 1) //If survival mode is on
	{
		acs_execute(310,0,1); //set smode on clientside
		delay(1);
		giveinventory("fist",1); //Give default starting items on survival
		giveinventory("pistol",1);
	}
	else
	{
		acs_execute(310,0,0); //set smode off clientside
	}
}

// Stub for 'start clock' callback
script 119 (void) { }

// Stub for 'checkpoint' callback
script 120 (int cp_number) { }

// stub for 'finish line' callback
script 121 (void) { }

// Start the clock for the player
script 219(int cp_total) { 
	//print(s:"219"); //debug
    // Clear the player's previous checkpoints 
    for (int i = 0;i <= cp_total;i++) {
        p_checkpoint[playernumber()][i] = 0;
    }

    p_starttic[playernumber()] = timer(); //set the player's start tic
	acs_executealways( 306, 0, 1); //start clientside timer 
    clear_time(cp_total); //clear checkpoints
    
    // Callback
    ACS_Execute(119, 0);
}

// Checkpoint
script 220(int cp_number) {
    // Make sure the player hasn't already crossed this point in his run
    if (p_checkpoint[playernumber()][cp_number] == 0 && p_starttic[playernumber()] != 0) {
        int p_time = timer() - p_starttic[playernumber()]; //set your checkpoint time equal to the timer less start tic
        p_checkpoint[playernumber()][cp_number] = p_time; //set checkpoint time
        
        if (p_top_checkpoint[playernumber()][cp_number] == 0) {
            // No prior time
            print_time(p_time, cp_number);
        } else if (p_time <= p_top_checkpoint[playernumber()][cp_number]) {
            // Even or improvement over previous time
            print_time_neg(p_top_checkpoint[playernumber()][cp_number] - p_time, cp_number);
        } else {
            // Slower than pervious time
            print_time_pos(p_time - p_top_checkpoint[playernumber()][cp_number], cp_number);
        }
        
        // Callback
        ACS_Execute(120, 0, cp_number);
    }
}

// End the clock for the player
script 221(int cp_total) {
    // Make sure the player hasn't already crossed this point in his run
    if (p_checkpoint[playernumber()][cp_total] == 0 && p_starttic[playernumber()] != 0) {
        int p_time = timer() - p_starttic[playernumber()]; //set your finish time equal to the timer less start tic
        p_checkpoint[playernumber()][cp_total] = p_time; //set checkpoint time
        
        // Did the player set his first time or beat his previous high score?
        if (p_top_time[playernumber()] == 0 || p_time <= p_top_time[playernumber()]) {
            // New times don't need to be compared to anything else
            if (p_top_time[playernumber()] == 0) {
                print_time(p_time, cp_total);
            } else {
                print_time_neg(p_top_checkpoint[playernumber()][cp_total] - p_time, cp_total);
            }
            
            // Copy the players time
            p_top_time[playernumber()] = p_time;
			acs_executealways(404, 0, p_time, playernumber()); //compare this time to the record
            for (int i = 0;i <= cp_total;i++) {
                p_top_checkpoint[playernumber()][i] = p_checkpoint[playernumber()][i];
            } //set new top checkpoints
            
            // Update HUD with best time
            best_time(p_time);
        } else {
            print_time_pos(p_time - p_top_checkpoint[playernumber()][cp_total], cp_total);
        }
        
        // Log the time we just turned in
        log_time(p_time);
        
        // Turn off the start tic, so the automatic HUD stops, then update
        // it ourselves with the most recent run time
        p_starttic[playernumber()] = 0;
		acs_executealways( 306, 0, 0); //stop clientside timer 
		delay(3); //delay to compensate for client server desync 
		acs_executealways(307, 0, p_time);  //set the hud to show most recent time clientside 
        
        // Callback
        ACS_Execute(121, 0);
    }
}

// Execute the ENTER script on respawn
script 300 RESPAWN {
	//print(s:"300 RESPAWN"); //debug
    ACS_Execute(100, 0);
}


// Initialize the players top time when he enters the level
script 301 ENTER {
    p_top_time[playernumber()] = 0;
    
    for (int i = 0;i < MAXCHECKPOINTS;i++) {
        p_top_checkpoint[playernumber()][i] = 0;
    }
	hudmessage(s:"";HUDMSG_PLAIN,300,CR_WHITE,0,0,0); //clear current personal best (since it doesn't work via disconnect) [Jroc]
}

// Timer, top time and speed on the HUD -- clientsided using a clientside start tic (p_cstarttic)
script 302 ENTER CLIENTSIDE {
	//print(s:"302 ENTER CLIENTSIDE"); //debug
	if(GetCvar("csmode") == 0)
		p_cstarttic[playernumber()] = 0; //reset the clientside start tic on re-entering
    while(TRUE) {
		//print(d:p_cstarttic[playernumber()]); //debug
        if (p_cstarttic[playernumber()] != 0) {
            // If we have a start tic to work from,
            // display the current time 
			acs_executealways(307, 0, timer() - p_cstarttic[playernumber()]);
        }
		else if(csmode == 1)
		{
			//print(s:"csmode=1"); //debug
			//acs_executealways(307, 0, timer() - p_cstarttic[playernumber()]); //pointless
		}
        delay(1);
    }
}

// Pause timer on death
script 303 DEATH {
	p_starttic[playernumber()] = 0;
	acs_execute(309,0); //set clientside start tic to 0 also
}

script 309 (void) CLIENTSIDE {
	p_cstarttic[playernumber()] = 0;
}

// Wipe that players' times from the records and reset his HUD
// edited: disconnect is activated by world and does NOT clear spectator only hud messages but intead clears everyone's
script 304 (int p_number) DISCONNECT {
	p_starttic[p_number] = 0;
	p_top_time[p_number] = 0;
	p_cstarttic[playernumber()] = 0;
	for (int i = 0;i<MAXCHECKPOINTS;i++) {
		p_checkpoint[p_number][i] = 0;
		p_top_checkpoint[p_number][i] = 0;
	}
	
	//clear_time(255);
	//for (int j = 300;j<=305;j++) {
		//hudmessage(s:"";HUDMSG_PLAIN,j,CR_WHITE,0,0,0);
	//}
}

// Used by DECORATE to simulate an item pickup
script 305 (void) {
	fadeto(255, 255, 128, 0.125, 0.0);
	fadeto(255, 255, 128, 0.0, 0.03);
}

script 306 (int timeron) CLIENTSIDE //set clientside variables
{
	if (timeron == 1)
	{
		p_cstarttic[playernumber()] = timer();
	}
	else
	{
		p_cstarttic[playernumber()] = 0;
	}
}

script 307 (int nowtimer) CLIENTSIDE //display timer clientside
{
	//print(s:"307"); //debug
		now_time(nowtimer);
}

script 308 ENTER CLIENTSIDE { //stub
	//if(GetCvar("csmode") == 0)
		//p_cstarttic[playernumber()] = 0; //reset the clientside start tic on re-entering
}

script 310 (int smodeon) CLIENTSIDE //clientside csmode switcher
{
	if (smodeon == 1)
		csmode = 1;
	else
		csmode = 0;
}

// Function that displays times in the lower right hand corner
// Lots of duplicate code, too bad ACS doesn't support string
// concatenation
function void print_time(int p_time, int cp_number) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
   if (mins == 0) {
        if (mils < 10) {
            hudmessage(d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else if (mils < 100) {
            hudmessage(d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else {
            hudmessage(d:secs,s:".",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        }
    }
}

function void print_time_neg(int p_time, int cp_number) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
   if (mins == 0) {
        if (mils < 10) {
            hudmessage(s:"-",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else if (mils < 100) {
            hudmessage(s:"-",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else {
            hudmessage(s:"-",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(s:"-",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(s:"-",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(s:"-",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(s:"-",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(s:"-",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(s:"-",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        }
    }
}

function void print_time_pos(int p_time, int cp_number) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessage(s:"+",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else if (mils < 100) {
            hudmessage(s:"+",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else {
            hudmessage(s:"+",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        }
    } else {
		if (secs < 10) {
	        if (mils < 10) {
            	hudmessage(s:"+",d:mins,s:":0",d:secs,s:".00",d:mils;
	                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else if (mils < 100) {
	            hudmessage(s:"+",d:mins,s:":0",d:secs,s:".0",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else {
	            hudmessage(s:"+",d:mins,s:":0",d:secs,s:".",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	}
		} else {
	        if (mils < 10) {
            	hudmessage(s:"+",d:mins,s:":",d:secs,s:".00",d:mils;
	                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else if (mils < 100) {
	            hudmessage(s:"+",d:mins,s:":",d:secs,s:".0",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else {
	            hudmessage(s:"+",d:mins,s:":",d:secs,s:".",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	}
		}
	}
}

// Clear lower right hand times 
function void clear_time(int cp_total) {
    for (int i = 0;i <= cp_total;i++) {
        hudmessage(s:"";
            HUDMSG_PLAIN, i + 100, CR_WHITE, 1.95,
            0.8 - ((i << FRACBITS) / 20), 0);
    }
}

function void best_time(int p_time) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessage(s:"Personal Best:\n",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
        } else if (mils < 100) {
            hudmessage(s:"Personal Best:\n",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
        } else {
            hudmessage(s:"Personal Best:\n",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else if (mils < 100) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else {
                hudmessage(s:"Personal Best:\n",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else if (mils < 100) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else {
                hudmessage(s:"Personal Best:\n",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            }
        }
    }
}

function void best_timealltime(int p_time, int rank, int points) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
			setfont("smallfont");
            hudmessage(s:"Personal Best (all time):\n",d:secs,s:".00",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
        } else if (mils < 100) {
			setfont("smallfont");
            hudmessage(s:"Personal Best (all time):\n",d:secs,s:".0",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
        } else {
			setfont("smallfont");
            hudmessage(s:"Personal Best (all time):\n",d:secs,s:".",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
				setfont("smallfont");
                hudmessage(s:"Personal Best (all time):\n",d:mins,s:":0",d:secs,s:".00",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                    HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
            } else if (mils < 100) {
				setfont("smallfont");
                hudmessage(s:"Personal Best (all time):\n",d:mins,s:":0",d:secs,s:".0",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                    HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
            } else {
				setfont("smallfont");
                hudmessage(s:"Personal Best (all time):\n",d:mins,s:":0",d:secs,s:".",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                    HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
            }
        } else {
            if (mils < 10) {
				setfont("smallfont");
                hudmessage(s:"Personal Best (all time):\n",d:mins,s:":",d:secs,s:".00",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                    HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
            } else if (mils < 100) {
				setfont("smallfont");
                hudmessage(s:"Personal Best (all time):\n",d:mins,s:":",d:secs,s:".0",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                    HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
            } else {
				setfont("smallfont");
                hudmessage(s:"Personal Best (all time):\n",d:mins,s:":",d:secs,s:".",d:mils,s:"\nRank: ",i:rank,s:" (",i:points,s:" points)";
                    HUDMSG_PLAIN, 303, CR_WHITE, 0.05, 0.7, 0);
            }
        }
    }
}

function void now_time(int p_time) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
		if (mils < 10) {
            hudmessage(s:"This Run:\n",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
        } else if (mils < 100) {
            hudmessage(s:"This Run:\n",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
        } else {
            hudmessage(s:"This Run:\n",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(s:"This Run:\n",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else if (mils < 100) {
                hudmessage(s:"This Run:\n",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else {
                hudmessage(s:"This Run:\n",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(s:"This Run:\n",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else if (mils < 100) {
                hudmessage(s:"This Run:\n",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else {
                hudmessage(s:"This Run:\n",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            }
        }
    }
}

// Log time in the console and top of the screen
function void log_time(int p_time) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
		if (mils < 10) {
            hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:secs,s:".00",d:mils;
				HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
        } else if (mils < 100) {
            hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:secs,s:".0",d:mils;
				HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
        } else {
            hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:secs,s:".",d:mils;
				HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else if (mils < 100) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            }
        } else {
            if (mils < 10) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else if (mils < 100) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            }
        }
    }

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            log(s:"STRUN ",n:playernumber() + 1,s:": ",d:secs,s:".00",d:mils);
        } else if (mils < 100) {
            log(s:"STRUN ",n:playernumber() + 1,s:": ",d:secs,s:".0",d:mils);
        } else {
            log(s:"STRUN ",n:playernumber() + 1,s:": ",d:secs,s:".",d:mils);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":0",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":0",d:secs,s:".0",d:mils);
            } else {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":0",d:secs,s:".",d:mils);
            }
        } else {
            if (mils < 10) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":",d:secs,s:".0",d:mils);
            } else {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":",d:secs,s:".",d:mils);
            }
        }
    }
}

// Print time for unloading
function void exit_time(int p_time, int plnum) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
		if (mils < 10) {
            printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:secs,s:".00",d:mils);
        } else if (mils < 100) {
            printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:secs,s:".0",d:mils);
        } else {
            printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:secs,s:".",d:mils);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:mins,s:":0",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
               printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:mins,s:":0",d:secs,s:".0",d:mils);
            } else {
                printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:mins,s:":0",d:secs,s:".",d:mils);
            }
        } else {
            if (mils < 10) {
                printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:mins,s:":",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:mins,s:":",d:secs,s:".0",d:mils);
            } else {
                printbold(s:"Time performed by ",n:plnum + 1,s:": \cf",d:mins,s:":",d:secs,s:".",d:mils);
            }
        }
    }

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            log(s:"STRUN ",n:plnum + 1,s:": ",d:secs,s:".00",d:mils);
        } else if (mils < 100) {
            log(s:"STRUN ",n:plnum + 1,s:": ",d:secs,s:".0",d:mils);
        } else {
            log(s:"STRUN ",n:plnum + 1,s:": ",d:secs,s:".",d:mils);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                log(s:"STRUN ",n:plnum + 1,s:": ",d:mins,s:":0",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                log(s:"STRUN ",n:plnum + 1,s:": ",d:mins,s:":0",d:secs,s:".0",d:mils);
            } else {
                log(s:"STRUN ",n:plnum + 1,s:": ",d:mins,s:":0",d:secs,s:".",d:mils);
            }
        } else {
            if (mils < 10) {
                log(s:"STRUN ",n:plnum + 1,s:": ",d:mins,s:":",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                log(s:"STRUN ",n:plnum + 1,s:": ",d:mins,s:":",d:secs,s:".0",d:mils);
            } else {
                log(s:"STRUN ",n:plnum + 1,s:": ",d:mins,s:":",d:secs,s:".",d:mils);
            }
        }
    }
}

// Functions that converts a given number of tics to either minutes, seconds
// or mileseconds
function int to_mins(int tics) {
    int mins = tics / (TICRATE * 60);
    return mins;
}

function int to_secs(int tics) {
    int secs = (tics / TICRATE) % 60;
    return secs;
}

function int to_mils(int tics) {
    int mils = tics % TICRATE;
    mils = ((mils * 1000) / TICRATE);
    return mils;
}

//=======================DATABASE INTERFACING=======================
#define F_TIME 0
#define F_NAME 1

int finaltimes[PLAYERMAX][2]; //times for end map leaderboard
int alltimes[MAXIDS][2]; //all time top times (unused currently)
int temprecord[PLAYERMAX]; //temporary variable for storing record
bool roundover;
bool z_tbypass; //used to check whether to bypass built in timelimit
int startplayercount;
int skill;

script 400 ENTER NET
{
	gone[playernumber()] = 0;
	str yourname = strparam(n:0);
	//print(s:"400 executing (debug)");
	if (GetDBEntryInt ("PlayerIds", yourname ) == 0) //if there is no ID associated with your name
	{
		//print(s:"making account (debug)");
		for (int i = 1; i < MAXIDS; i++) //find a spare id and set that to his name
		{
			str playerid = strparam(i:i);
			if (StrLen(GetDBEntryString ("PlayerNames", playerid )) == 0 || GetDBEntryString ("PlayerNames", playerid ) == "")
			{
				SetDBEntryString ("PlayerNames", playerid, yourname);
				SetDBEntryString ("PlayerIds", yourname, playerid);
				break;
			}
		}
	}
	str yourid = strparam(i:GetDBEntryInt ("PlayerIds", yourname ));
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	str maplumppbs = strparam(s:maplump,s:"pbs");
	str maplumprank = strparam(s:maplump,s:"rank");
	str maplumppoints = strparam(s:maplump,s:"points");
	if (getcvar("z_smode") == 0)
	{
		acs_executealways(411,0);
	}
	else
	{
		//print(s:"getting rec (debug)");
		str smodepbspace = strparam(s:maplumppbs,s:"s",i:skill);
		if (GetDBEntryInt (smodepbspace,yourid) != 0)
			best_timealltime(GetDBEntryInt (smodepbspace,yourid),GetDBEntryRank (maplumppbs,yourid, TRUE ),GetDBEntryInt (maplumppoints,yourid));
	}
}

script 411 (void)
{
	int iterations = 0;
	while(gone[playernumber()] == 0 && roundover == false)
	{
		str yourname = strparam(n:0); //have to do this because strparam only lasts 1 tic
		str yourid = strparam(i:GetDBEntryInt ("PlayerIds", yourname )); 
		str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
		str maplumppbs = strparam(s:maplump,s:"pbs");
		str maplumprank = strparam(s:maplump,s:"rank");
		str maplumppoints = strparam(s:maplump,s:"points");
		
		if (GetDBEntryInt (maplumppbs,yourid) != 0)
			best_timealltime(GetDBEntryInt (maplumppbs,yourid),GetDBEntryRank (maplumppbs,yourid, TRUE ),GetDBEntryInt (maplumppoints,yourid)); //show your all time personal best
		if (GetDBEntryInt ("totalpoints",yourid) != 0)
		{
			setfont("smallfont");
			hudmessage(s:"Total points on server: ",i:GetDBEntryInt ("totalpoints",yourid),s:"\nOverall rank: ",i:GetDBEntryRank ("totalpoints",yourid, FALSE ); HUDMSG_PLAIN, 304, CR_WHITE, 0.05, 0.8, 0);
		}
		//if (GetDBEntryInt (maplumppbs,yourid) != 0)
		//{
			//SetDBEntryInt (maplumprank, yourid, GetDBEntryRank (maplumppbs,yourid, TRUE));
			//SetDBEntryInt (maplumppoints, yourid, getpoints(GetDBEntryRank (maplumppbs,yourid, TRUE)));
		//}
		
		//if (iterations == 0) //don't execute this too frequently
		//{
			//iterations++;
			//acs_execute(464,0,GetDBEntryInt ("PlayerIds", yourname ));
		//}
		//else
			//iterations = 0;
		
		delay(35*4 + playernumber()*5);
	}
}

script 412 OPEN
{
	//printbold(n:PRINTNAME_LEVEL,s:" (debug)");
	skill = getcvar("skill");
	startplayercount = playercount();
	hudmessage(s:""; HUDMSG_PLAIN, 511, CR_WHITE, 0, 0, 0);
	hudmessage(s:""; HUDMSG_PLAIN, 512, CR_WHITE, 0, 0, 0);
}

script 402 OPEN NET
{
	delay(10);
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	if (getcvar("z_smode") == 1)
	{
		int players;
		if (startplayercount == 0)
			players = 1;
		else
			players = startplayercount;
		str timekey = strparam(s:"SModeRecordTimeP",i:players,s:"s",i:skill);
		//printbold(s:timekey); //debug
		if (GetDBEntryInt (maplump, timekey ) != 0)
		{
			setfont("smallfont");
			show_author(0.05,0.43, "");
			show_therecord(GetDBEntryInt (maplump, timekey ));
		}
	}
	else if (GetDBEntryInt (maplump, "MapRecordTime" ) != 0) //show global map record
	{
		setfont("smallfont");
		show_author(0.05,0.43, "");
		show_therecord(GetDBEntryInt (maplump, "MapRecordTime" ));
	}
	if (GetDBEntryInt ("MapIds", maplump ) == 0) //set map id
	{
		for (int i = 1; i < MAXIDS; i++) //find a spare id and set that to map lump name
		{
			str mapid = strparam(i:i);
			if (StrLen(GetDBEntryString ("MapNames", mapid )) == 0 || GetDBEntryString ("MapNames", mapid ) == "")
			{
				SetDBEntryString ("MapNames", mapid, maplump);
				SetDBEntryString ("MapIds", maplump, mapid);
				break;
			}
		}
	}
}

script 403 ENTER CLIENTSIDE
{
	consolecommand("puke 402");
}

script 409 OPEN CLIENTSIDE //this is for spectators to see the record
{
	delay(1);
	if (PlayerInGame (ConsolePlayerNumber()) == FALSE)
	{//clear hud messages for spectators
		for (int j = 300;j<=305;j++) {
			hudmessage(s:"";HUDMSG_PLAIN,j,CR_WHITE,0,0,0);
		}
	}
	//print(s:"409 executing");
	consolecommand("puke 402");
	delay(1);
	consolecommand("puke 400");
}

script 410 OPEN { //basic timer
	if(getcvar("z_smode") == 1)
	{
		int time = 0;

		while ( true ) {
			TimerShowTime( time );
			time += 1;
			delay( TICRATE );
		}
	}
}

function void TimerShowTime( int time ) {
   setFont( "BIGFONT" );
   hudMessage(
      i : time / SECONDS_IN_MINUTE, 
      s : "  :  ", 
      i : ( time % SECONDS_IN_MINUTE ) / 10, 
      s : "  ", i : time % 10 ;
      HUDMSG_PLAIN, 985, CR_BLUE, 0.95, 0.95, 0
   );
}
		
script 401 (void) //displays final scores then exits
{	
	delay(1); //note, for whatever reason sync issues required me to put a couple of delays in here
	roundover = true; //declare the round over for enter and respawn to freeze you
	delay(5);
	for (int j = 0;j<=999;j++) {
		hudmessage(s:""; HUDMSG_PLAIN, j, CR_WHITE, 0, 0, 0); //clear hud messages
	}
	SetPlayerProperty(1, 1, PROP_TOTALLYFROZEN); //freeze player
	for (int herp = 0; herp < PLAYERMAX; herp++) //for each entry in finaltimes
	{
		finaltimes[herp][F_TIME] = p_top_time[herp]; //set the value at index "herp" to the top time of player "herp"
		finaltimes[herp][F_NAME] = herp + 1; //set the player number to be "herp" plus 1, for use with n:
	}
	for (int derp = 0; derp < PLAYERMAX; derp++)
	{
		if (finaltimes[derp][F_TIME] == 0) //if an entry has a top time of zero...
			finaltimes[derp][F_TIME] = 99999999; //set it to a huge number (so it doesn't affect sorting)
	}
	delay(1);
	hsort(); //shell sort
	if (finaltimes[0][F_TIME] == 99999999) //if the highest ranking entry is 99999999 (indicating no time set)
	{
		printbold(s:"Wow, nodoby managed to beat the course! You guys suck."); //insult the players for being shit (as nobody managed to get a time)
		delay(TICRATE*5);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[0][F_TIME], finaltimes[0][F_NAME], 0.2, "\ca1st", 501); //otherwise show the highest ranking entry as first place
	}
	if (finaltimes[1][0] == 99999999) //if the second highest ranking entry is 99999999 (indicating no time set)
	{
		delay(TICRATE*10); //wait, and then exit, don't display second place as he didn't get a time
		zr_exit(); 
	}
	else
	{
		finaltime(finaltimes[1][F_TIME], finaltimes[1][F_NAME], 0.3, "\cb2nd", 502); //otherwise show second place
	}
	if (finaltimes[2][0] == 99999999) //if the third highest ranking entry is 99999999 (indicating no time set) and so on...
	{
		delay(TICRATE*10);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[2][F_TIME], finaltimes[2][F_NAME], 0.4, "\cc3rd", 503);
	}
	if (finaltimes[3][0] == 99999999)
	{
		delay(TICRATE*10);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[3][F_TIME], finaltimes[3][F_NAME], 0.5, "\cd4th", 504);
	}
	if (finaltimes[4][0] == 99999999)
	{
		delay(TICRATE*10);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[4][F_TIME], finaltimes[4][F_NAME], 0.6, "\ce5th", 505);
	}
	delay(TICRATE*10);
	zr_exit();
}

script 404 (int timec, int player) //for checking new time against record
{
	int gotrec;
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	if (timec < GetDBEntryInt (maplump, "MapRecordTime" ) && timec != 0 || GetDBEntryInt (maplump, "MapRecordTime" ) == 0 && timec != 0) //if the time is quicker than record
	{
		str recauthor = strparam(n:player + 1);
		SetDBEntryString (maplump, "MapRecordAuthor", recauthor );
		SetDBEntryInt (maplump, "MapRecordTime", timec );
		printbold(s:"record has been set"); //debug
		show_author(0.05,0.43, "");
		show_therecord(GetDBEntryInt (maplump, "MapRecordTime" ));
		ambientSound( "JM2HSWIN", 127 );
		gotrec = 1;
	}
	str maplumppbs = strparam(s:maplump,s:"pbs");
	str maplumprank = strparam(s:maplump,s:"rank");
	str maplumppoints = strparam(s:maplump,s:"points");
	str yourname = strparam(n:0);
	if (GetDBEntryInt ("PlayerIds", yourname ) == 0)
		terminate;
	str yourid = strparam(i:GetDBEntryInt ("PlayerIds", yourname ));
	if (timec < GetDBEntryInt (maplumppbs,yourid) && timec != 0)  
	{
		SetDBEntryInt (maplumppbs, yourid, timec );
		SetDBEntryInt (maplumprank, yourid, GetDBEntryRank (maplumppbs,yourid, TRUE));
		SetDBEntryInt (maplumppoints, yourid, getpoints(GetDBEntryRank (maplumppbs,yourid, TRUE)));
		best_timealltime(GetDBEntryInt (maplumppbs,yourid),GetDBEntryRank (maplumppbs,yourid, TRUE ),GetDBEntryInt (maplumppoints,yourid));
		if (gotrec == 0)
			 LocalAmbientSound("pbest", 127);
		//acs_execute(464,0,GetDBEntryInt ("PlayerIds", yourname ));
	}
	else if (GetDBEntryInt (maplumppbs,yourid) == 0 && timec != 0)
	{
		SetDBEntryInt (maplumppbs, yourid, timec );
		SetDBEntryInt (maplumprank, yourid, GetDBEntryRank (maplumppbs,yourid, TRUE));
		SetDBEntryInt (maplumppoints, yourid, getpoints(GetDBEntryRank (maplumppbs,yourid, TRUE)));
		best_timealltime(GetDBEntryInt (maplumppbs,yourid),GetDBEntryRank (maplumppbs,yourid, TRUE ),GetDBEntryInt (maplumppoints,yourid));
		//acs_execute(464,0,GetDBEntryInt ("PlayerIds", yourname ));
		LocalAmbientSound("pbest", 127);
	}	
}

script 405 ENTER //freeze players if the round is over
{
	if (roundover == false)
	{
		SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
		SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	}
	else
	{
		SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
	}
}

script 406 RESPAWN
{
	acs_executealways(405, 0);
}

script 453 RETURN
{
	//print(s:"453 RETURN"); //debug
	acs_executealways(100, 0); //probably useless
}

script 407 OPEN //Waits a certain amount of time, shows leaderboard, and then exits. I originally wanted to use zandronum's in built timer but this turned out to not be practical
{
	delay(1);
	if (z_tbypass == true) //Check if the map disabled in built time limit
		terminate;
	if (getcvar("z_tlimit") == 0) {consolecommand("set z_tlimit 0"); delay(TICRATE); restart; } //Check if a timelimit has been set using z_tlimit
	int Time = GetCVar("z_tlimit")*60;
	Until(Time == 0)
	{
		if (Time <= 60){
			SetFont("BIGFONT");
			HudMessageBold(s:"Round Ends In: \cg", d:Time/60, s:":", d:(Time%60)/10, d:Time%10; HUDMSG_PLAIN, 2, CR_WHITE, 0.81, 0.85, 3.5);
			delay(35);
			Time--;
		}else if (Time > 60 && Time <= 180){
			SetFont("BIGFONT");
			HudMessageBold(s:"Round Ends In: \ck", d:Time/60, s:":", d:(Time%60)/10, d:Time%10; HUDMSG_PLAIN, 2, CR_WHITE, 0.81, 0.85, 3.5);
			delay(35);
			Time--;
		}else if (Time > 180){
			SetFont("BIGFONT");
			HudMessageBold(s:"Round Ends In: \cd", d:Time/60, s:":", d:(Time%60)/10, d:Time%10; HUDMSG_PLAIN, 2, CR_WHITE, 0.81, 0.85, 3.5);
			delay(35);
			Time--;
		}
	}
	acs_execute(401,0);
}

script 408 (void) //Script for maps to activate should they want to bypass any built in time limit.
{
	z_tbypass = true;
}

//Ijontichy's acs scripts for making rocket splash not affect other people, don't ask me how this works

#define DEFAULTTID_SCRIPT 471

function int unusedTID(int start, int end)
{
    int ret = start - 1;
    int tidNum;

    if (start > end) { start ^= end; end ^= start; start ^= end; }  // good ol' XOR swap
    
    while (ret++ != end)
    {
        if (ThingCount(0, ret) == 0)
        {
            return ret;
        }
    }
    
    return -1;
}

function int defaultTID(int def)
{
    return _defaulttid(def, 0);
}

function int _defaulttid(int def, int alwaysPropagate)
{
    if (ClassifyActor(0) & ACTOR_WORLD) { return 0; }

    int tid = ActivatorTID();
    int i, changed = 0;

    if (ThingCount(0, tid) != 1)
    {
        tid = def;
        changed = 1;
        if (def <= 0)
        {
            i = random(12, 220);
            tid = unusedTID(i*100, (i+100)*100);
        }

        Thing_ChangeTID(0, tid);
    }

    if ((changed || (alwaysPropagate == 1)) && (alwaysPropagate != 2))
    {
        ACS_ExecuteAlways(DEFAULTTID_SCRIPT, 0, tid,0,0);
    }

    return tid;
}

script DEFAULTTID_SCRIPT (int tid) clientside
{
    if (ConsolePlayerNumber() == -1) { terminate; }
    Thing_ChangeTID(0, tid);
}

/*
 *  End commonFuncs.h
 */

int PlayerTIDs[PLAYERMAX];

script 653 enter
{
    int pln = PlayerNumber();

    while (1)
    {
        PlayerTIDs[pln] = defaultTID(0);
        Delay(1);
    }
}

script 654 (int onOff, int xflags1, int xflags2)
{
    // calling from projectile?
    if (onOff < 2 && onOff >= 0) { SetActivatorToTarget(0); }
    onOff &= 1;

    int i, exclude, success;
    int mypln = PlayerNumber();

    for (i = 0; i < PLAYERMAX; i++)
    {
        if (i >= 32) { exclude = xflags2 & (1 << (i-32)); }
        else { exclude = xflags1 & (1 << i); }

        success = PlayerInGame(i) && !(i == mypln || exclude);
        if (!success) { continue; }

        if (onOff) { GiveActorInventory(PlayerTIDs[i], "DisableShootableFlag", 1); }
        else { GiveActorInventory(PlayerTIDs[i], "EnableShootableFlag", 1); }
    }
}

//Positron's shell sort
void hsort() {
   // Figure out initial increment.
   int h = 0;
   int h_next = 1;
   do {
      h = h_next;
      h_next = 3 * h + 1;
   } while ( h_next < PLAYERMAX );
   // Sort.
   while ( h ) {
      int sorted = h;
      while ( sorted < PLAYERMAX ) {
         int i = sorted;
         int time = finaltimes[ i ][ F_TIME ];
         str name = finaltimes[ i ][ F_NAME ];
         while ( i >= h && time < finaltimes[ i - h ][ F_TIME ] ) {
            finaltimes[ i ][ F_TIME ] = finaltimes[ i - h ][ F_TIME ];
            finaltimes[ i ][ F_NAME ] = finaltimes[ i - h ][ F_NAME ];
            i -= h;
         }
         finaltimes[ i ][ F_TIME ] = time;
         finaltimes[ i ][ F_NAME ] = name;
         ++sorted;
      }
      h = ( h - 1 ) / 3;
   }
}

void hsortDB(int size) {
   // Figure out initial increment.
   int h = 0;
   int h_next = 1;
   do {
      h = h_next;
      h_next = 3 * h + 1;
   } while ( h_next < size );
   // Sort.
   while ( h ) {
      int sorted = h;
      while ( sorted < size ) {
         int i = sorted;
         int time = alltimes[ i ][ F_TIME ];
         str name = alltimes[ i ][ F_NAME ];
         while ( i >= h && time < alltimes[ i - h ][ F_TIME ] ) {
            alltimes[ i ][ F_TIME ] = alltimes[ i - h ][ F_TIME ];
            alltimes[ i ][ F_NAME ] = alltimes[ i - h ][ F_NAME ];
            i -= h;
         }
         alltimes[ i ][ F_TIME ] = time;
         alltimes[ i ][ F_NAME ] = name;
         ++sorted;
      }
      h = ( h - 1 ) / 3;
   }
}

//function to display leaderboard times
function void finaltime(int p_time, int player, int height, str pos, int id) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);
	setfont("bigfont");

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        } else if (mils < 100) {
            hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        } else {
            hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else if (mils < 100) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            }
        } else {
            if (mils < 10) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else if (mils < 100) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            }
        }
    }
}

function void alltime(int p_time, str player, int height, str pos, int id) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);
	setfont("bigfont");

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        } else if (mils < 100) {
            hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        } else {
            hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else if (mils < 100) {
                hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else {
                hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            }
        } else {
            if (mils < 10) {
                hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else if (mils < 100) {
                hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else {
                hudmessagebold(s:pos,s:": ",s:player,s:" - ",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            }
        }
    }
}

//shows the record and record holder
function void show_author(int posx, int posy, int modifier)
{
	setfont("smallfont");
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	int players;
	if (startplayercount == 0)
		players = 1;
	else
		players = startplayercount;
	str moddisplay = strparam(s:"(Record for skill ",d:skill,s:" and ",d:players,s:" players)");
	str recget = strparam(s:"SModeAuthor1p",i:players,s:"s",i:skill);
	if (getcvar("z_smode") == 0)
	{
		setfont("smallfont");
		hudmessagebold(s:"Record set by: ",s:GetDBEntryString (maplump, "MapRecordAuthor" ), s:"\n",s:modifier;
        HUDMSG_PLAIN, 512, CR_WHITE, posx, posy, 0);
	}
	else if (startplayercount == 0 || startplayercount == 1)
	{
		setfont("smallfont");
		hudmessagebold(s:"Record set by: ",s : GetDBEntryString (maplump, recget ), s:"\n",s:moddisplay;
        HUDMSG_PLAIN, 512, CR_WHITE, posx, posy, 0);
	}
	else
	{
		setfont("smallfont");
		hudmessagebold(s:"Record by multiple authors", s:"\n",s:moddisplay,s:"\n",s:"(puke 466 for authors)";
        HUDMSG_PLAIN, 512, CR_WHITE, posx, posy, 0);
	}
}
function void show_therecord(int p_time) {
 //record author is stored in an array of characters
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);
	setfont("smallfont");

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
			setfont("smallfont");
            hudmessagebold(s:"Serverside record:\n",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
        } else if (mils < 100) {
			setfont("smallfont");
            hudmessagebold(s:"Serverside record:\n",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
        } else {
			setfont("smallfont");
            hudmessagebold(s:"Serverside record:\n",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
				setfont("smallfont");
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else if (mils < 100) {
				setfont("smallfont");
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else {
				setfont("smallfont");
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            }
        } else {
            if (mils < 10) {
				setfont("smallfont");
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else if (mils < 100) {
				setfont("smallfont");
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else {
				setfont("smallfont");
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            }
        }
    }
}

//function to exit, adds interfacing to voter (vote wad by Hypnotoad)
function void zr_exit(void)
{
	acs_execute(456,0);
	/*
	if (GetCvar("zanvoter") == 1)
	{
		acs_execute(501, 0);
	}
	else
	{
		Exit_Normal(0);
	}*/
}

function void zr_exit2(void)
{
	if (GetCvar("zanvoter") == 1)
	{
		acs_execute(501, 0);
	}
	else
	{
		Exit_Normal(0);
	}
}

script 456 (void)
{
	int entries;
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	str maplumppbs = strparam(s:maplump,s:"pbs");
	for (int j = 0;j<=999;j++) {
		hudmessage(s:""; HUDMSG_PLAIN, j, CR_WHITE, 0, 0, 0); //clear hud messages
	/* out with the old in with the new
	for (int herp = 0; herp < MAXIDS; herp++) //for each entry in alltimes
	{
		str herpid = strparam(i:herp + 1);
		if(StrLen(GetDBEntryString ("PlayerNames", herpid )) == 0)
		{
			entries = herp + 1;
			break;
		}
		alltimes[herp][F_TIME] = GetDBEntryInt (maplumppbs,herpid); //set the value at index "herp" to the top time of player "herp"
		alltimes[herp][F_NAME] = GetDBEntryString ("PlayerNames", herpid );
	}
	//log(s:"first loop done");
	for (int derp = 0; derp < MAXIDS; derp++)
	{
		if (alltimes[derp][F_TIME] == 0) //if an entry has a top time of zero...
			alltimes[derp][F_TIME] = 99999999; //set it to a huge number (so it doesn't affect sorting)
	}
	//log(s:"second loop done");
	hsortDB(entries); //shll sort
	//log(s:"3rd loop done");
	*/
	int Top5 = QuerySortedDBEntries (maplumppbs, 5, 0, 1 );
	setfont("BIGFONT");
	hudmessagebold(s:"All Time Top Five"; HUDMSG_PLAIN, 500, CR_WHITE, 0.5, 0.1, 0);
	int numEntries = GetDBResultSize(Top5);
	if (numEntries == 0) //if there is no top 5
	{
		printbold(s:"No personal bests for this map are in the database"); 
		delay(TICRATE*5);
		ClearDBResultHandle ( Top5 );
		zr_exit2();
	}
	else
	{
		alltime(GetDBEntryInt (maplumppbs,GetDBResultEntryNameString(Top5, 0)), GetDBEntryString ("PlayerNames", GetDBResultEntryNameString(Top5, 0)), 0.2, "\ca1st", 501); //show the highest ranking entry as first place
	}
	if (numEntries == 1) 
	{
		delay(TICRATE*10); //wait, and then exit, don't display second place as he didn't get a time
		ClearDBResultHandle ( Top5 );
		zr_exit2(); 
	}
	else
	{
		alltime(GetDBEntryInt (maplumppbs,GetDBResultEntryNameString(Top5, 1)), GetDBEntryString ("PlayerNames", GetDBResultEntryNameString(Top5, 1)), 0.3, "\cb2nd", 502); //otherwise show second place
	}
	if (numEntries == 2) 
	{
		delay(TICRATE*10);
		ClearDBResultHandle ( Top5 );
		zr_exit2();
	}
	else
	{
		alltime(GetDBEntryInt (maplumppbs,GetDBResultEntryNameString(Top5, 2)), GetDBEntryString ("PlayerNames", GetDBResultEntryNameString(Top5, 2)), 0.4, "\cc3rd", 503);
	}
	if (numEntries  == 3)
	{
		delay(TICRATE*10);
		ClearDBResultHandle ( Top5 );
		zr_exit2();
	}
	else
	{
		alltime(GetDBEntryInt (maplumppbs,GetDBResultEntryNameString(Top5, 3)), GetDBEntryString ("PlayerNames", GetDBResultEntryNameString(Top5, 3)), 0.5, "\cd4th", 504);
	}
	if (numEntries  == 4)
	{
		delay(TICRATE*10);
		ClearDBResultHandle ( Top5 );
		zr_exit2();
	}
	else
	{
		alltime(GetDBEntryInt (maplumppbs,GetDBResultEntryNameString(Top5, 4)), GetDBEntryString ("PlayerNames", GetDBResultEntryNameString(Top5, 4)), 0.6, "\ce5th", 505);
	}
	delay(TICRATE*10);
	ClearDBResultHandle ( Top5 );
	zr_exit2();
}
	
}

int exiter[4];

script 452 UNLOADING //SINGLE MODE
{
	if (GetCvar("z_smode") == 1)
	{
		str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
		exiter[0] = 64;
		int p_time = timer();
		int playeri = 0;
		for(int eter = 0; eter < 64; eter++)
		{
			if(Playeringame(eter) == FALSE)
			{
				continue;
			}
			else
			{
				exiter[playeri] = eter;
				if (playeri + 1 == startplayercount || playeri + 1 == 4)
					break;
				playeri++;
				continue;
			}
		}
		if (exiter[0] == 64) //if nobody was in game, don't store record
			terminate;
		exit_time(p_time,exiter[0]);
		if (TRUE) //don't ask
		{
			int players;
			if (startplayercount == 0)
				players = 1;
			else
				players = startplayercount;
			if (players == 1)
			{
				str smodepbspace = strparam(s:maplump,s:"pbss",i:skill);
				str playername = strparam(n:exiter[0] + 1);
				str playerid = strparam(i:GetDBEntryInt ("PlayerIds", playername));
				if (p_time < GetDBEntryInt (smodepbspace, playerid ) && p_time != 0 || GetDBEntryInt (smodepbspace, playerid ) == 0 && p_time != 0)
				{
					SetDBEntryInt (smodepbspace, playerid, p_time );
				}
			}
			str timekey = strparam(s:"SModeRecordTimeP",i:players,s:"s",i:skill);
			if (p_time < GetDBEntryInt (maplump, timekey ) && p_time != 0 || GetDBEntryInt (maplump, timekey ) == 0 && p_time != 0)
			{
				printbold(s:"Record beaten!!");
				str authorkey = strparam(s:"SModeAuthor1p",i:players,s:"s",i:skill);
				str authorname1 = strparam(n:exiter[0] + 1);
				SetDBEntryString (maplump, authorkey, authorname1 );
				SetDBEntryInt (maplump, timekey, p_time );
				if (playeri > 0) //save additional authors
				{
					for (int i = 1; i < playeri + 1; i++)
					{
						SetDBEntryString (maplump, strparam(s:"SModeAuthor",i:i+1,s:"p",i:players,s:"s",i:skill), strparam(n:exiter[i] + 1));
					}
				}
			}
		}
	}
}

str strtoupper( str string ) { //converts to uppercase (bcc code) by Positron
   return StrParam( {} ) := {
      int i = 0;
      while ( i < StrLen( string ) ) {
         // Character encoding assumed to be ASCII.
         if ( GetChar( string, i ) >= 97 && GetChar( string, i ) <= 122 ) {
            c:= GetChar( string, i ) - 32;
         }
         else {
            c:= GetChar( string, i );
         }
         ++i;
      }
   }
}

script 466 (void) NET
{
	print(s:"Not implemented yet!");
}

script 455 (void) NET
{
	//print(s:tempauthors[0],s:"\n",s:tempauthors[1],s:"\n",s:tempauthors[2],s:"\n",s:tempauthors[3]);
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	str maplumppbs = strparam(s:maplump,s:"pbs");
	str yourname = strparam(n:0);
	if (GetDBEntryInt ("PlayerIds", yourname ) == 0)
		terminate;
	str yourid = strparam(i:GetDBEntryInt ("PlayerIds", yourname ));
	print(s:"Your best: ",i:GetDBEntryInt (maplumppbs,yourid));
}

// ===========PERSONAL TELEPORT==========

script 460 (void) NET
{
	if (GetCvar("z_smode") == 0)
	{
		int x = GetActorX(0);
		int y = GetActorY(0);
		int z = GetActorZ(0);
		playerhealth[playernumber()] = GetActorProperty(0,APROP_Health);
		playerarmor[playernumber()] = CheckInventory("armor");
		for (int i = 0; i < ARMORTYPES; i++)
		{
			if (GetArmorType(armor_types[i], PlayerNumber()))
			{
				playerarmortype[playernumber()] = armor_types[i];
				break;
			}
		}
		//print(s:playerarmortype[playernumber()],s:" (debug)");//debug
		if (CheckInventory("RocketLauncher")  > 0)
			GotRL[playernumber()] = 1;
		rammo[playernumber()] = CheckInventory("RocketAmmo");
		int angle = GetActorAngle(0) >> 8;
		Thing_Remove (1000+ playernumber());
		spawn("MapSpot",x,y,z,1000+ playernumber(),angle);
	}
}

script 461 (void) NET
{
	if (GetCvar("z_smode") == 0)
	{
		if (ThingCountName("MapSpot",1000+ playernumber()) == 0)
		{
			print(s:"No teleport destination set, did you spawn it too close to a wall?");
			terminate;
		}
		if (teleportclearinv == 1)
			acs_executealways(100,0);
		else
		{
			if (playerhealth[playernumber()] > 0 && playerhealth[playernumber()] < 201)
				SetActorProperty(0,APROP_Health,playerhealth[playernumber()]);
			if (playerarmor[playernumber()] > 0 && playerarmor[playernumber()] < 201)
			{
				TakeInventory("BasicArmor", 999);
				if (playerarmortype[playernumber()] == "GreenArmor")
				{
					GiveInventory("GreenArmor", 1);
					TakeInventory("BasicArmor", 100 - playerarmor[playernumber()]);
				}
				else if (playerarmortype[playernumber()] == "BlueArmor" || playerarmortype[playernumber()] == "BlueArmorForMegasphere")
				{
					GiveInventory("BlueArmor", 1);
					TakeInventory("BasicArmor", 200 - playerarmor[playernumber()]);
				}
				else
					GiveInventory("ArmorBonus", playerarmor[playernumber()]);
			}
			if (GotRL[playernumber()] == 1)
			{
				GiveInventory("RocketLauncher", 1);
				TakeInventory("RocketAmmo", CheckInventory("RocketAmmo"));
				GiveInventory("RocketAmmo", rammo[playernumber()]);
			}
		}
		p_starttic[playernumber()] = 0;
		acs_execute(309,0);
		thing_Move (0,1000+ playernumber(), 1);
		Thing_Stop (0);
		SetActorAngle(0,GetActorAngle(1000+ playernumber()));
	}
}

//Database fixing scripts, puke these as admin

script 462 (void)
{
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	str maplumppbs = strparam(s:maplump,s:"pbs");
	str maplumprank = strparam(s:maplump,s:"rank");
	str maplumppoints = strparam(s:maplump,s:"points");
	//print(s:"(debug) hypno points: ",i:getpoints(GetDBEntryRank (maplumppbs,1, TRUE)));
	for (int i = 1; i < MAXIDS; i++) 
	{
		str playerid = strparam(i:i);
		if (StrLen(GetDBEntryString ("PlayerNames", playerid )) == 0 || GetDBEntryString ("PlayerNames", playerid ) == "")
		{
			print(s:"breaking with player id: ",s:playerid);
			break;
		}
		if (GetDBEntryInt (maplumppbs, playerid ) != 0)
		{
			SetDBEntryInt (maplumprank, playerid, GetDBEntryRank (maplumppbs,playerid, TRUE));
			SetDBEntryInt (maplumppoints, playerid, getpoints(GetDBEntryRank (maplumppbs,playerid, TRUE)));
		}
	}
}

function int getpoints (int rank)
{
	int ret;
	if (rank == 1)
	{
		ret = 100;
	}
	else
	{
		ret = 99 - rank;
	}
	return ret;
}

script 463 (void) //this is a hefty script, puke with caution
{
	for (int i = 1; i < MAXIDS; i++)
	{
		int points = 0;
		str playerid = strparam(i:i);
		if (StrLen(GetDBEntryString ("PlayerNames", playerid )) == 0 || GetDBEntryString ("PlayerNames", playerid ) == "")
			break;
		for (int l = 1; l < MAXIDS; l++) 
		{
			str mapid = strparam(i:l);
			if (StrLen(GetDBEntryString ("MapNames", mapid )) == 0 || GetDBEntryString ("MapNames", mapid ) == "")
				break;
			str maplumppoints = strparam(s:GetDBEntryString ("MapNames", mapid ),s:"points");
			points += GetDBEntryInt(maplumppoints,playerid);	
		}
		SetDBEntryInt ("totalpoints", playerid, points);
		delay(5);
	}
}

//point accumulator

script 464 (int id)
{
	int points = 0;
	str playerid = strparam(i:id);
	if (StrLen(GetDBEntryString ("PlayerNames", playerid )) == 0 || GetDBEntryString ("PlayerNames", playerid ) == "")
		terminate;
	for (int l = 1; l < MAXIDS; l++) 
	{
		str mapid = strparam(i:l);
		if (StrLen(GetDBEntryString ("MapNames", mapid )) == 0 || GetDBEntryString ("MapNames", mapid ) == "")
			break;
		str maplumppoints = strparam(s:GetDBEntryString ("MapNames", mapid ),s:"points");
		points += GetDBEntryInt(maplumppoints,playerid);	
	}
	SetDBEntryInt ("totalpoints", playerid, points);
	setfont("smallfont");
	hudmessage(s:"Total points on server: ",i:GetDBEntryInt ("totalpoints",playerid),s:"\nOverall rank: ",i:GetDBEntryRank ("totalpoints",playerid, FALSE ); HUDMSG_PLAIN, 304, CR_WHITE, 0.05, 0.8, 0);
}

//maps execute this to clear inventory on teleport
script 465 (void)
{
	teleportclearinv = 1;
}

script 468 DEATH
{
	gone[playernumber()] = 1;
}

script 467 (int player) DISCONNECT
{
	gone[player] = 1;
}

script 469 OPEN //global DB map updator
{
	str maplump = strtoupper(strparam(n:PRINTNAME_LEVEL));
	str maplumppbs = strparam(s:maplump,s:"pbs");
	str maplumprank = strparam(s:maplump,s:"rank");
	str maplumppoints = strparam(s:maplump,s:"points");
	//print(s:"(debug) hypno points: ",i:getpoints(GetDBEntryRank (maplumppbs,1, TRUE)));
	While(TRUE)
	{
		for (int i = 1; i < MAXIDS; i++) 
		{
			str playerid = strparam(i:i);
			if (StrLen(GetDBEntryString ("PlayerNames", playerid )) == 0 || GetDBEntryString ("PlayerNames", playerid ) == "")
			{
				//print(s:"breaking with player id: ",s:playerid);
				break;
			}
			if (GetDBEntryInt (maplumppbs, playerid ) != 0)
			{
				if (GetDBEntryInt(maplumprank, playerid) != GetDBEntryRank (maplumppbs,playerid, TRUE))
				{
					SetDBEntryInt (maplumprank, playerid, GetDBEntryRank (maplumppbs,playerid, TRUE));
					SetDBEntryInt (maplumppoints, playerid, getpoints(GetDBEntryRank (maplumppbs,playerid, TRUE)));
				}
			}
		}
		acs_executewait(463,0);
		delay(60);
		//printbold(s:"looping 469");
	}
	
}