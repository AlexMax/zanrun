#library "zanrun"
#include "zcommon.acs"
#import "luk/luk.acs"

#define PLAYERMAX 32
#define MAXCHECKPOINTS 255
#define TICRATE 35
#define FRACBITS 16
#define FRACUNIT (1 << FRACBITS)

// Designate the tics where player hits the start/cp
int p_starttic[PLAYERMAX];
int p_checkpoint[PLAYERMAX][MAXCHECKPOINTS];
int p_cstarttic[PLAYERMAX]; //clientside starttic [Jroc]
int csmode; //clientside z_smode check

// Stores the players best time on this map.
int p_top_time[PLAYERMAX];
int p_top_checkpoint[PLAYERMAX][MAXCHECKPOINTS];

// The default script to start the map with.
script 100 ENTER {
	//print(s:"100 ENTER"); //debug
    ClearInventory();
    SetActorProperty(0, APROP_Health, 100);
	if (GetCvar("z_smode") == 1)
	{
		clearinventory();
		acs_execute(219,0);
		acs_execute(310,0,1); //set smode on clientside
		delay(1);
		giveinventory("fist",1);
		giveinventory("pistol",1);
	}
	else
	{
		acs_execute(310,0,0);
	}
}

// Stub for 'start clock' callback
script 119 (void) { }

// Stub for 'checkpoint' callback
script 120 (int cp_number) { }

// stub for 'finish line' callback
script 121 (void) { }

// Start the clock for the player
script 219(int cp_total) { 
	//print(s:"219"); //debug
    // Clear the player's previous checkpoints 
    for (int i = 0;i <= cp_total;i++) {
        p_checkpoint[playernumber()][i] = 0;
    }

    p_starttic[playernumber()] = timer();
	acs_executealways( 306, 0, 1); //start clientside timer [Jroc]
    clear_time(cp_total);
    
    // Callback
    ACS_Execute(119, 0);
}

// Checkpoint
script 220(int cp_number) {
    // Make sure the player hasn't already crossed this point in his run
    if (p_checkpoint[playernumber()][cp_number] == 0 && p_starttic[playernumber()] != 0) {
        int p_time = timer() - p_starttic[playernumber()];
        p_checkpoint[playernumber()][cp_number] = p_time;
        
        if (p_top_checkpoint[playernumber()][cp_number] == 0) {
            // No prior time
            print_time(p_time, cp_number);
        } else if (p_time <= p_top_checkpoint[playernumber()][cp_number]) {
            // Even or improvement over previous time
            print_time_neg(p_top_checkpoint[playernumber()][cp_number] - p_time, cp_number);
        } else {
            // Slower than pervious time
            print_time_pos(p_time - p_top_checkpoint[playernumber()][cp_number], cp_number);
        }
        
        // Callback
        ACS_Execute(120, 0, cp_number);
    }
}

// End the clock for the player
script 221(int cp_total) {
    // Make sure the player hasn't already crossed this point in his run
    if (p_checkpoint[playernumber()][cp_total] == 0 && p_starttic[playernumber()] != 0) {
        int p_time = timer() - p_starttic[playernumber()];
        p_checkpoint[playernumber()][cp_total] = p_time;
        
        // Did the player set his first time or beat his previous high score?
        if (p_top_time[playernumber()] == 0 || p_time <= p_top_time[playernumber()]) {
            // New times don't need to be compared to anything else
            if (p_top_time[playernumber()] == 0) {
                print_time(p_time, cp_total);
            } else {
                print_time_neg(p_top_checkpoint[playernumber()][cp_total] - p_time, cp_total);
            }
            
            // Copy the players time
            p_top_time[playernumber()] = p_time;
			acs_executealways(404, 0, p_time, playernumber()); //ZANRUN EDIT, COMPARE TO RECORD
            for (int i = 0;i <= cp_total;i++) {
                p_top_checkpoint[playernumber()][i] = p_checkpoint[playernumber()][i];
            }
            
            // Update HUD with best time
            best_time(p_time);
        } else {
            print_time_pos(p_time - p_top_checkpoint[playernumber()][cp_total], cp_total);
        }
        
        // Log the time we just turned in
        log_time(p_time);
        
        // Turn off the start tic, so the automatic HUD stops, then update
        // it ourselves with the most recent run time
        p_starttic[playernumber()] = 0;
		acs_executealways( 306, 0, 0); //stop clientside timer [Jroc]
		delay(3); //delay to compensate for client server desync [Jroc]
		acs_executealways(307, 0, p_time);  //set the hud to show mot recent time clientside [Jroc]
        
        // Callback
        ACS_Execute(121, 0);
    }
}

// Execute the ENTER script on respawn
script 300 RESPAWN {
	//print(s:"300 RESPAWN"); //debug
    ACS_Execute(100, 0);
}


// Initialize the players top time when he enters the level
script 301 ENTER {
    p_top_time[playernumber()] = 0;
    
    for (int i = 0;i < MAXCHECKPOINTS;i++) {
        p_top_checkpoint[playernumber()][i] = 0;
    }
	hudmessage(s:"";HUDMSG_PLAIN,300,CR_WHITE,0,0,0); //clear current personal best (since it doesn't work via disconnect) [Jroc]
}

// Timer, top time and speed on the HUD -- clientsided by Jroc, using a clientside start tic (p_cstarttic)
script 302 ENTER CLIENTSIDE {
	//print(s:"302 ENTER CLIENTSIDE"); //debug
    while(TRUE) {
		//print(d:p_cstarttic[playernumber()]); //debug
        if (p_cstarttic[playernumber()] != 0) {
            // If we have a start tic to work from,
            // display the current time 
			acs_executealways(307, 0, timer() - p_cstarttic[playernumber()]);
        }
		else if(csmode == 1)
		{
			//print(s:"csmode=1"); //debug
			acs_executealways(307, 0, timer() - p_cstarttic[playernumber()]);
		}
        delay(1);
    }
}

// Pause timer on death
script 303 DEATH {
	p_starttic[playernumber()] = 0;
}

// Wipe that players' times from the records.and reset his HUD
// edited by Jroc, disconnect is activated by world and does NOT clear spectator only hud messages but intead clears everyone's
script 304 (int p_number) DISCONNECT {
	p_starttic[p_number] = 0;
	p_top_time[p_number] = 0;
	p_cstarttic[playernumber()] = 0;
	for (int i = 0;i<MAXCHECKPOINTS;i++) {
		p_checkpoint[32][i] = 0;
		p_top_checkpoint[32][i] = 0;
	}
	
	//clear_time(255);
	//for (int j = 300;j<=305;j++) {
		//hudmessage(s:"";HUDMSG_PLAIN,j,CR_WHITE,0,0,0);
	//}
}

// Used by DECORATE to simulate an item pickup
script 305 (void) {
	fadeto(255, 255, 128, 0.125, 0.0);
	fadeto(255, 255, 128, 0.0, 0.03);
}

script 306 (int timeron) CLIENTSIDE //set clientside variables
{
	if (timeron == 1)
	{
		p_cstarttic[playernumber()] = timer();
	}
	else
	{
		p_cstarttic[playernumber()] = 0;
	}
}

script 307 (int nowtimer) CLIENTSIDE //display timer clientside
{
	//print(s:"307"); //debug
	now_time(nowtimer);
}

script 308 ENTER CLIENTSIDE {
	if(GetCvar("csmode") == 0)
		p_cstarttic[playernumber()] = 0; //reset the clientside start tic on re-entering
}

script 310 (int smodeon) CLIENTSIDE
{
	if (smodeon == 1)
	{
		csmode = 1;
	}
	else
	{
		csmode = 0;
	}
}

// Function that displays times in the lower right hand corner
// Lots of duplicate code, too bad ACS doesn't support string
// concatenation
function void print_time(int p_time, int cp_number) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
   if (mins == 0) {
        if (mils < 10) {
            hudmessage(d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else if (mils < 100) {
            hudmessage(d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else {
            hudmessage(d:secs,s:".",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_WHITE, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        }
    }
}

function void print_time_neg(int p_time, int cp_number) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
   if (mins == 0) {
        if (mils < 10) {
            hudmessage(s:"-",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else if (mils < 100) {
            hudmessage(s:"-",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else {
            hudmessage(s:"-",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(s:"-",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(s:"-",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(s:"-",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(s:"-",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else if (mils < 100) {
                hudmessage(s:"-",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            } else {
                hudmessage(s:"-",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, cp_number + 100, CR_GREEN, 1.95,
                    0.8 - ((cp_number << FRACBITS) / 20), 0);
            }
        }
    }
}

function void print_time_pos(int p_time, int cp_number) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessage(s:"+",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else if (mils < 100) {
            hudmessage(s:"+",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        } else {
            hudmessage(s:"+",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                0.8 - ((cp_number << FRACBITS) / 20), 0);
        }
    } else {
		if (secs < 10) {
	        if (mils < 10) {
            	hudmessage(s:"+",d:mins,s:":0",d:secs,s:".00",d:mils;
	                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else if (mils < 100) {
	            hudmessage(s:"+",d:mins,s:":0",d:secs,s:".0",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else {
	            hudmessage(s:"+",d:mins,s:":0",d:secs,s:".",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	}
		} else {
	        if (mils < 10) {
            	hudmessage(s:"+",d:mins,s:":",d:secs,s:".00",d:mils;
	                HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else if (mils < 100) {
	            hudmessage(s:"+",d:mins,s:":",d:secs,s:".0",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	} else {
	            hudmessage(s:"+",d:mins,s:":",d:secs,s:".",d:mils;
                	HUDMSG_PLAIN, cp_number + 100, CR_RED, 1.95,
                	0.8 - ((cp_number << FRACBITS) / 20), 0);
        	}
		}
	}
}

// Clear lower right hand times 
function void clear_time(int cp_total) {
    for (int i = 0;i <= cp_total;i++) {
        hudmessage(s:"";
            HUDMSG_PLAIN, i + 100, CR_WHITE, 1.95,
            0.8 - ((i << FRACBITS) / 20), 0);
    }
}

function void best_time(int p_time) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessage(s:"Personal Best:\n",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
        } else if (mils < 100) {
            hudmessage(s:"Personal Best:\n",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
        } else {
            hudmessage(s:"Personal Best:\n",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else if (mils < 100) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else {
                hudmessage(s:"Personal Best:\n",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else if (mils < 100) {
                hudmessage(s:"Personal Best:\n",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            } else {
                hudmessage(s:"Personal Best:\n",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 300, CR_WHITE, 0.05, 0.5, 0);
            }
        }
    }
}

function void now_time(int p_time) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
		if (mils < 10) {
            hudmessage(s:"This Run:\n",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
        } else if (mils < 100) {
            hudmessage(s:"This Run:\n",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
        } else {
            hudmessage(s:"This Run:\n",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessage(s:"This Run:\n",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else if (mils < 100) {
                hudmessage(s:"This Run:\n",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else {
                hudmessage(s:"This Run:\n",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            }
        } else {
            if (mils < 10) {
                hudmessage(s:"This Run:\n",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else if (mils < 100) {
                hudmessage(s:"This Run:\n",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            } else {
                hudmessage(s:"This Run:\n",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 301, CR_WHITE, 0.05, 0.6, 0);
            }
        }
    }
}

// Log time in the console and top of the screen
function void log_time(int p_time) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
		if (mils < 10) {
            hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:secs,s:".00",d:mils;
				HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
        } else if (mils < 100) {
            hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:secs,s:".0",d:mils;
				HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
        } else {
            hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:secs,s:".",d:mils;
				HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else if (mils < 100) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            }
        } else {
            if (mils < 10) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else if (mils < 100) {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            } else {
                hudmessagebold(s:"Time performed by ",n:playernumber() + 1,s:": \cf",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_FADEOUT | HUDMSG_LOG, 302, CR_GOLD, 1.5, 0.05, 5.0);
            }
        }
    }

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            log(s:"STRUN ",n:playernumber() + 1,s:": ",d:secs,s:".00",d:mils);
        } else if (mils < 100) {
            log(s:"STRUN ",n:playernumber() + 1,s:": ",d:secs,s:".0",d:mils);
        } else {
            log(s:"STRUN ",n:playernumber() + 1,s:": ",d:secs,s:".",d:mils);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":0",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":0",d:secs,s:".0",d:mils);
            } else {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":0",d:secs,s:".",d:mils);
            }
        } else {
            if (mils < 10) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":",d:secs,s:".00",d:mils);
            } else if (mils < 100) {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":",d:secs,s:".0",d:mils);
            } else {
                log(s:"STRUN ",n:playernumber() + 1,s:": ",d:mins,s:":",d:secs,s:".",d:mils);
            }
        }
    }
}

// Function that converts a given number of tics to either minutes, seconds
// or mileseconds
function int to_mins(int tics) {
    int mins = tics / (TICRATE * 60);
    return mins;
}

function int to_secs(int tics) {
    int secs = (tics / TICRATE) % 60;
    return secs;
}

function int to_mils(int tics) {
    int mils = tics % TICRATE;
    mils = ((mils * 1000) / TICRATE);
    return mils;
}

//==========ZANRUN==================
#define F_TIME 0
#define F_NAME 1

int finaltimes[PLAYERMAX][2]; //times for end map leaderboard
int temprecord; //temporary variable for storing record
bool recdone;
int _jrs_hs_author[ LUK_MAX_STR_VALUE_SIZE ]; //record holder
bool roundover;
bool z_tbypass; //used to check whether to bypass built in timelimit

script 403 OPEN
{
	if (getcvar("luk_system") < 1) { delay(TICRATE); restart; }
		// Load high score finish time.
		acs_ExecuteWait( 970, 0, LUK_RETQUERY_INT, "jrs_hs_time" );

		int result = LukGetQueryResult();
		if ( result != LUK_RESULT_OK ) {
			// If luk returns an error code, that means no high score is set.
			if ( result == LUK_RESULT_FAILED ) {
				printbold(s:"No high score set for this map");
			}
			// Error.
			else {
				printbold(s:"Record return error");
			}
			recdone = true;
			temprecord = 0;
			terminate;
		}

		temprecord = LukGetData(); //copy record time to variable
		acs_ExecuteWait( 970, 0, LUK_RETQUERY_STR, "jrs_hs_author" );
		if ( result != LUK_RESULT_OK ) {
			// If luk returns an error code, that means no high score is set.
			if ( result == LUK_RESULT_FAILED ) {
				printbold(s:"No high score set for this map");
			}
			// Error.
			else {
				printbold(s:"Record return error");
			}
			recdone = true;
			temprecord = 0;
			terminate;
		}
		
		JrsHsSetAuthor(); //copy record author to new variable
		recdone = true;
}

script 402 ENTER //used to synchronise client with luk
{
	if (getcvar("luk_system") < 1) { delay(TICRATE); restart; }
	if (recdone == false)
	{
		ScriptWait(403);
		if (temprecord != 0)
			show_therecord(temprecord);
	}
	else
	{
		if (temprecord != 0)
			show_therecord(temprecord);
	}
}
		
script 401 (void) //displays final scores then exits
{	
	roundover = true; //declare the round over for enter and respawn to freeze you
	for (int j = 0;j<=999;j++) {
		hudmessage(s:""; HUDMSG_PLAIN, j, CR_WHITE, 0, 0, 0); //clear hud messages
	}
	SetPlayerProperty(1, 1, PROP_TOTALLYFROZEN); //freeze player
	for (int herp = 0; herp < PLAYERMAX; herp++) //for each entry in finaltimes
	{
		finaltimes[herp][F_TIME] = p_top_time[herp]; //set the value at index "herp" to the top time of player "herp"
		finaltimes[herp][F_NAME] = herp + 1; //set the player number to be "herp" plus 1, for use with n:
	}
	for (int derp = 0; derp < PLAYERMAX; derp++)
	{
		if (finaltimes[derp][F_TIME] == 0) //if an entry has a top time of zero...
			finaltimes[derp][F_TIME] = 99999999; //set it to a huge number (so it doesn't affect sorting)
	}
	int temp = 0;
	int temp2 = 0;
    for (int write = 0; write < PLAYERMAX; write++) //bubble sort
    {
		for (int sort = 0; sort < PLAYERMAX - 1; sort++)
        {
			if (finaltimes[sort][F_TIME] > finaltimes[sort + 1][F_TIME])
            {
				temp = finaltimes[sort + 1][F_TIME];
                finaltimes[sort + 1][F_TIME] = finaltimes[sort][F_TIME];
                finaltimes[sort][F_TIME] = temp;
                temp2 = finaltimes[sort + 1][F_NAME];
                finaltimes[sort + 1][F_NAME] = finaltimes[sort][F_NAME];
                finaltimes[sort][F_NAME] = temp2;
             }
        }
    }


	if (finaltimes[0][F_TIME] == 99999999) //if the highest ranking entry is 99999999 (indicating no time set)
	{
		printbold(s:"Wow, nodoby managed to beat the course! You guys suck."); //insult the players for being shit (as nobody managed to get a time)
		delay(TICRATE*5);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[0][F_TIME], finaltimes[0][F_NAME], 0.2, "\ca1st", 501); //otherwise show the highest ranking entry as first place
	}
	if (finaltimes[1][0] == 99999999) //if the second highest ranking entry is 99999999 (indicating no time set)
	{
		delay(TICRATE*10); //wait, and then exit, don't display second place as he didn't get a time
		zr_exit(); 
	}
	else
	{
		finaltime(finaltimes[1][F_TIME], finaltimes[1][F_NAME], 0.3, "\cb2nd", 502); //otherwise show second place
	}
	if (finaltimes[2][0] == 99999999) //if the third highest ranking entry is 99999999 (indicating no time set) and so on and so on...
	{
		delay(TICRATE*10);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[2][F_TIME], finaltimes[2][F_NAME], 0.4, "\cc3rd", 503);
	}
	if (finaltimes[3][0] == 99999999)
	{
		delay(TICRATE*10);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[3][F_TIME], finaltimes[3][F_NAME], 0.5, "\cd4th", 504);
	}
	if (finaltimes[4][0] == 99999999)
	{
		delay(TICRATE*10);
		zr_exit();
	}
	else
	{
		finaltime(finaltimes[4][F_TIME], finaltimes[4][F_NAME], 0.6, "\ce5th", 505);
	}
	delay(TICRATE*10);
	zr_exit();
}

script 404 (int timec, int player) //for checking new time against record
{
	if (getcvar("luk_system") == 1)
	{
		if (timec < temprecord && timec != 0 || temprecord == 0 && timec != 0)
		{
			JrsHsSave(player, timec); //save record
			temprecord = timec;
			acs_ExecuteWait( 970, 0, LUK_RETQUERY_STR, "jrs_hs_author" );
			int result = LukGetQueryResult();
			if ( result != LUK_RESULT_OK ) {
				// If luk returns an error code, that means no high score is set.
				if ( result == LUK_RESULT_FAILED ) {
					printbold(s:"Error requesting record");
				}
				// Error.
				else {
					printbold(s:"Error requesting record");
				}
				terminate;
			}		
			JrsHsSetAuthor();
			show_therecord(temprecord); //update hud
			printbold(n:player + 1,s:" just set a new record!");
		}
	}
}

script 405 ENTER //freeze players if the round is over
{
	if (roundover == false)
	{
		SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
		SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	}
	else
	{
	SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
	}
}

script 406 RESPAWN
{
	acs_executealways(405, 0);
}

script 453 RETURN
{
	//print(s:"453 RETURN"); //debug
	acs_executealways(100, 0);
}

script 407 OPEN //Waits a certain amount of time, shows leaderboard, and then exits. I originally wanted to use zandronum's in built timer but this turned out to not be practical
{
	delay(1);
	if (z_tbypass == true) //Check if the map disabled in built time limit
		terminate;
	if (getcvar("z_tlimit") == 0) {consolecommand("set z_tlimit 0"); delay(TICRATE); restart; } //Check if a timelimit has been set using z_tlimit
	print(d:getcvar("z_tlimit"), s:" minutes remaining!");
	if (getcvar("z_tlimit") < 2)
	{
		delay(TICRATE*50);
		print(s:"\cg10 SECONDS REMAINING!");
		delay(TICRATE*10);
		acs_execute(401,0);
	}
	else if (getcvar("z_tlimit") < 6)
	{
		delay(TICRATE*60*(getcvar("z_tlimit") - 1));
		print(s:"1 minute remaining!!");
		delay(TICRATE*50);
		print(s:"\cg10 SECONDS REMAINING!");
		delay(TICRATE*10);
		acs_execute(401,0);
	}
	else
	{
		delay(TICRATE*60*(getcvar("z_tlimit") - 5));
		print(s:"5 minutes remaining!!");
		delay(TICRATE*60*4);
		print(s:"1 minute remaining!!");
		delay(TICRATE*50);
		print(s:"\cg10 SECONDS REMAINING!");
		delay(TICRATE*10);
		acs_execute(401,0);
	}
}

script 408 (void) //Script for maps to activate should they want to bypass any built in time limit.
{
	z_tbypass = true;
}

//Ijontichy's acs scripts for making rocket splash not affect other people

#define DEFAULTTID_SCRIPT 471

function int unusedTID(int start, int end)
{
    int ret = start - 1;
    int tidNum;

    if (start > end) { start ^= end; end ^= start; start ^= end; }  // good ol' XOR swap
    
    while (ret++ != end)
    {
        if (ThingCount(0, ret) == 0)
        {
            return ret;
        }
    }
    
    return -1;
}

function int defaultTID(int def)
{
    return _defaulttid(def, 0);
}

function int _defaulttid(int def, int alwaysPropagate)
{
    if (ClassifyActor(0) & ACTOR_WORLD) { return 0; }

    int tid = ActivatorTID();
    int i, changed = 0;

    if (ThingCount(0, tid) != 1)
    {
        tid = def;
        changed = 1;
        if (def <= 0)
        {
            i = random(12, 220);
            tid = unusedTID(i*100, (i+100)*100);
        }

        Thing_ChangeTID(0, tid);
    }

    if ((changed || (alwaysPropagate == 1)) && (alwaysPropagate != 2))
    {
        ACS_ExecuteAlways(DEFAULTTID_SCRIPT, 0, tid,0,0);
    }

    return tid;
}

script DEFAULTTID_SCRIPT (int tid) clientside
{
    if (ConsolePlayerNumber() == -1) { terminate; }
    Thing_ChangeTID(0, tid);
}

/*
 *  End commonFuncs.h
 */

int PlayerTIDs[PLAYERMAX];

script 1201 enter
{
    int pln = PlayerNumber();

    while (1)
    {
        PlayerTIDs[pln] = defaultTID(0);
        Delay(1);
    }
}

script 1202 (int onOff, int xflags1, int xflags2)
{
    // calling from projectile?
    if (onOff < 2 && onOff >= 0) { SetActivatorToTarget(0); }
    onOff &= 1;

    int i, exclude, success;
    int mypln = PlayerNumber();

    for (i = 0; i < PLAYERMAX; i++)
    {
        if (i >= 32) { exclude = xflags2 & (1 << (i-32)); }
        else { exclude = xflags1 & (1 << i); }

        success = PlayerInGame(i) && !(i == mypln || exclude);
        if (!success) { continue; }

        if (onOff) { GiveActorInventory(PlayerTIDs[i], "DisableShootableFlag", 1); }
        else { GiveActorInventory(PlayerTIDs[i], "EnableShootableFlag", 1); }
    }
}

//function to display leaderboard times
function void finaltime(int p_time, int player, int height, str pos, int id) {
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);
	setfont("bigfont");

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        } else if (mils < 100) {
            hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        } else {
            hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else if (mils < 100) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            }
        } else {
            if (mils < 10) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else if (mils < 100) {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            } else {
                hudmessagebold(s:pos,s:": ",n:player,s:" - ",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, id, CR_WHITE, 0.5, height, 0);
            }
        }
    }
}
//saves the record to luk database
function void JrsHsSave( int player, int tics ) { 
	LukStoreName( "jrs_hs_author", player );
	LukStoreInt( "jrs_hs_time", tics );
	LukStoreDate( "jrs_hs_rdate" );
}
//retrieves record author from luk database
function void JrsHsSetAuthor( void ) {
   for ( int c = 0; c < LUK_MAX_STR_VALUE_SIZE; c += 1 ) {
      _jrs_hs_author[ c ] = _luk_str_value[ c ];

      if ( _luk_str_value[ c ] == '\0' ) {
         break;
      }
   }
}
//shows the record and record holder
function void show_therecord(int p_time) {
	hudmessagebold(s:"Record set by: ",a : _jrs_hs_author;
        HUDMSG_PLAIN, 512, CR_WHITE, 0.05, 0.43, 0); //record author is stored in an array of characters
    int mins = to_mins(p_time);
    int secs = to_secs(p_time);
    int mils = to_mils(p_time);

    // Any minutes?
    if (mins == 0) {
        if (mils < 10) {
            hudmessagebold(s:"Serverside record:\n",d:secs,s:".00",d:mils;
                HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
        } else if (mils < 100) {
            hudmessagebold(s:"Serverside record:\n",d:secs,s:".0",d:mils;
                HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
        } else {
            hudmessagebold(s:"Serverside record:\n",d:secs,s:".",d:mils;
                HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
        }
    } else {
        if (secs < 10) {
            if (mils < 10) {
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":0",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else if (mils < 100) {
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":0",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else {
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":0",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.5, 0);
            }
        } else {
            if (mils < 10) {
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":",d:secs,s:".00",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else if (mils < 100) {
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":",d:secs,s:".0",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            } else {
                hudmessagebold(s:"Serverside record:\n",d:mins,s:":",d:secs,s:".",d:mils;
                    HUDMSG_PLAIN, 511, CR_WHITE, 0.05, 0.4, 0);
            }
        }
    }
}

//function to exit, adds interfacing to voter (vote wad by Hypnotoad)
function void zr_exit(void)
{
	if (GetCvar("zanvoter") == 1)
	{
		acs_execute(501, 0);
	}
	else
	{
		Exit_Normal(0);
	}
}

script 452 UNLOADING //SINGLE MODE
{
	if (GetCvar("z_smode") == 1)
	{
		int exiter;
		int p_time = timer() - p_starttic[playernumber()];
		p_top_time[playernumber()] = p_time;
		for(int eter = 0; eter < 64; eter++)
		{
			if(Playeringame(eter) == FALSE)
			{
				continue;
			}
			else
			{
				exiter = eter;
				break;
			}
		}
		if (getcvar("luk_system") == 1)
		{
			if (p_time < temprecord && p_time != 0 || temprecord == 0 && p_time != 0)
			{
				JrsHsSave(exiter, p_time); //save record
			}
		}
	}
}